# DEPENDENCIES
import torch
import os


# UTILITY FUNCTIONS
def save_model(model, model_name: str, save_dir: str = "./models"):
    """
    Save the model's state_dict to a file
    
    Arguments:
    ----------
        model        {torch.nn.Module} : The model to save

        model_name   {str}             : The name of the model (used for filename)

        save_dir     {str}             : Directory to save the model
    """
    # Create the models directory if it doesn't exist
    os.makedirs(save_dir, exist_ok=True)  
    model_path = os.path.join(save_dir, f"{model_name}_model.pth")
    
    # Save the state_dict of the model
    torch.save(model.state_dict(), model_path) 
    print(f"Model saved at {model_path}")


def load_model(model, model_name: str, save_dir: str = "./models"):
    """
    Load the model's state_dict from a file
    
    Arguments:
    ----------
        model        { torch.nn.Module } : The model to load the weights into

        model_name         { str }       : The name of the model (used for filename)

        save_dir           { str }       : Directory from which to load the model
        
    Returns:
    --------
        model        {torch.nn.Module}   : The model with loaded weights
    """
    model_path = os.path.join(save_dir, f"{model_name}_model.pth")
    
    if os.path.exists(model_path):
        model.load_state_dict(torch.load(model_path))
        model.eval()  # Set the model to evaluation mode
        print(f"Model loaded from {model_path}")
    
    else:
        print(f"Model file {model_path} not found. Returning uninitialized model.")
    
    return model


def get_actual_and_generated_images(model, dataloader, device, num_images=5):
    """
    Utility to extract actual and generated images using a trained model.

    Arguments:
    ----------
    model            { torch.nn.Module }       : The trained model to generate images

    dataloader { torch.utils.data.DataLoader } : The DataLoader providing the test dataset

    device            { torch.device }         : The device (CPU/GPU) to run the model

    num_images             { int }             : The number of images to visualize (default is 5)

    Returns:
    --------
                { list of torch.Tensor }       : List of actual images from the dataset
               
                { list of torch.Tensor }       : List of corresponding images generated by the model
    """
    # Set the model to evaluation mode
    model.eval()  
    actual_images    = list()
    generated_images = list()

    with torch.no_grad():  # Disable gradient computation for inference
        for inputs, _ in dataloader:
            inputs  = inputs.to(device)

            # Forward pass to generate images
            outputs = model(inputs)

            # Collect images
            actual_images.extend(inputs[:num_images].cpu())  # Gets actual images
            generated_images.extend(outputs[:num_images].cpu())  # Gets generated images
            
            # Stop after collecting the desired number of images
            if (len(actual_images) >= num_images):
                break

    # Ensure the lists only contain the required number of images
    actual_images    = actual_images[:num_images]
    generated_images = generated_images[:num_images]

    return actual_images, generated_images

